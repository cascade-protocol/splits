# Cascade Splits SDK v0.8.0 - Implementation Plan

**Date:** 2025-12-02
**Goal:** Prepare SDK for `@faremeter/splits` integration with optimized RPC efficiency

---

## Executive Summary

This release adds high-level transaction execution helpers and intelligent caching to support the faremeter integration. All changes are **additive and non-breaking**.

| Change | Purpose | Impact |
|--------|---------|--------|
| Add `executeAndConfirmSplit()` | One-call split execution for faremeter wrapper | Enables thin faremeter plugin |
| Add `isCascadeSplit` caching | 75% RPC reduction for facilitators | Production-ready for high volume |
| Add protocol config caching | Self-healing cache with auto-retry | 1 fewer RPC per execution |
| Add `minBalance` threshold | Micropayment batching support | Cost optimization for users |
| Add priority fee support | `computeUnitLimit` + `computeUnitPrice` options | Reliability during congestion |
| Auto-detect Token-2022 | Detect token program from vault owner | Zero-config Token-2022 support |
| New `execute.ts` module | Clean separation of concerns | Maintainable architecture |

---

## Part 1: Faremeter Integration Context

### 1.1 The Problem

Faremeter is the x402 infrastructure layer. To integrate Cascade Splits:
- We need a wrapper that intercepts `handleSettle`
- After payment lands in vault, automatically call `execute_split`
- Must be thin and delegate logic to SDK

### 1.2 Decision: SDK Owns Execution Logic

**Options considered:**
1. Put execution logic in faremeter wrapper (~80 lines)
2. Put execution logic in SDK, faremeter wrapper calls SDK (~15 lines)

**Decision: Option 2**

**Reasoning:**
- Less code for faremeter team to review → easier approval
- Tested logic lives in SDK → bugs are our responsibility
- Other integrations (PayAI, direct users) benefit from same helper
- Faremeter wrapper becomes trivial:

```typescript
// Entire faremeter wrapper implementation
const splitResult = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer);
return { ...result, splitTxHash: splitResult.ok ? splitResult.signature : null };
```

### 1.3 Decision: Subpath Exports for Multi-Chain

**Options considered:**
1. Unified client (wagmi-style): `createSplitsClient({ chains: [...] })`
2. Adapter interface: `SplitsAdapter` implemented per chain
3. Subpath exports: `@cascade-fyi/splits-sdk/solana`, `/evm`
4. Namespace exports: `splits.solana.*`, `splits.evm.*`

**Decision: Option 3 (Subpath Exports)**

**Reasoning:**
- Solana and EVM have fundamentally different dependencies (`@solana/kit` vs `viem`)
- Unified client would force both dependency trees on all users
- Subpath exports enable perfect tree-shaking
- Each chain module is self-contained
- Matches faremeter's own pattern (`@faremeter/payment-solana`, `@faremeter/payment-evm`)

```typescript
// Solana user - only @solana/kit in bundle
import { executeAndConfirmSplit } from "@cascade-fyi/splits-sdk/solana";

// EVM user (future) - only viem in bundle
import { executeAndConfirmSplit } from "@cascade-fyi/splits-sdk/evm";
```

---

## Part 2: New Function - `executeAndConfirmSplit`

### 2.1 Purpose

High-level helper that handles the full transaction lifecycle:
1. Build `executeSplit` instruction
2. Create versioned transaction
3. Sign with provided signer
4. Send to network
5. Wait for confirmation

### 2.2 API Design

```typescript
import type {
  Address,
  Rpc,
  SolanaRpcApi,
  KeyPairSigner,
  RpcSubscriptions,
  SignatureNotificationsApi,
  SlotNotificationsApi,
} from "@solana/kit";

export interface ExecuteAndConfirmOptions {
  /** Only execute if vault balance >= this amount (in token base units) */
  minBalance?: bigint;
  /** Commitment level for confirmation (default: 'confirmed') */
  commitment?: 'processed' | 'confirmed' | 'finalized';
  /** Abort signal for timeout/cancellation support */
  abortSignal?: AbortSignal;
  /** Compute unit limit (default: 200_000) */
  computeUnitLimit?: number;
  /** Priority fee in microlamports per compute unit */
  computeUnitPrice?: bigint;
}

export type ExecuteAndConfirmResult =
  | { ok: true; signature: string }
  | { ok: false; reason: "not_found" | "not_a_split" | "below_threshold" }
  | { ok: false; reason: "send_failed" | "expired" | "aborted"; error: Error; programErrorCode?: number };

export async function executeAndConfirmSplit(
  rpc: Rpc<SolanaRpcApi>,
  rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi>,
  vault: Address,
  signer: KeyPairSigner,
  options?: ExecuteAndConfirmOptions,
): Promise<ExecuteAndConfirmResult>;
```

**Note:** Requires `rpcSubscriptions` (WebSocket connection) for efficient confirmation.
Users without WebSocket can use low-level `executeSplit()` and handle confirmation themselves.

**WebSocket Setup Example:**

```typescript
import { createSolanaRpc, createSolanaRpcSubscriptions } from "@solana/kit";

// HTTP RPC for queries
const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

// WebSocket RPC for subscriptions (confirmation)
const rpcSubscriptions = createSolanaRpcSubscriptions("wss://api.mainnet-beta.solana.com");

// Now use both
const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer);
```

### 2.3 Decision: Include `minBalance` Threshold

**Problem:** For micropayments, executing after every $0.001 payment is wasteful.

**Options considered:**
1. No threshold - always execute
2. `minBalance` option - skip if vault balance too low
3. Full `BatchExecutor` with timing + threshold

**Decision: Option 2 (minBalance only)**

**Reasoning:**
- Timing-based batching requires persistent state (last execution time per vault)
- State management adds complexity, belongs at application layer
- `minBalance` is stateless - just check vault balance before executing
- Can add `BatchExecutor` in v0.9.0 after real-world feedback

```typescript
// Facilitator can set minimum viable execution amount
const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer, {
  minBalance: 1_000_000n, // 1 USDC - don't execute for dust
});

if (!result.ok && result.reason === "below_threshold") {
  // Skip execution, will batch with next payment
}
```

### 2.4 Decision: Include `abortSignal` Support

**Problem:** Long-running transactions need timeout/cancellation capability.

**Decision: Add optional `abortSignal` parameter**

**Reasoning:**
- Matches `@solana/kit` patterns (most functions accept `abortSignal`)
- Enables facilitators to set transaction timeouts
- Allows graceful cancellation during shutdown
- Zero overhead when not used

```typescript
// With timeout - abort after 30 seconds
const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer, {
  abortSignal: AbortSignal.timeout(30_000),
});

if (!result.ok && result.reason === "aborted") {
  console.log("Transaction timed out or was cancelled");
}

// With manual abort controller
const controller = new AbortController();
setTimeout(() => controller.abort(), 60_000); // 60s timeout

const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer, {
  abortSignal: controller.signal,
});
```

### 2.5 Decision: New File `execute.ts`

**Options considered:**
1. Add to `instructions.ts`
2. Add to `helpers.ts`
3. New file `execute.ts`

**Decision: Option 3**

**Reasoning:**
- `instructions.ts` = builds `Instruction` objects, doesn't execute
- `helpers.ts` = read functions, PDA derivation
- `executeAndConfirmSplit` = transaction execution (different abstraction level)
- Clean separation makes codebase navigable

### 2.6 Decision: Use @solana/kit's sendAndConfirmTransactionFactory

**Options considered:**
1. Custom polling loop with `getSignatureStatuses` (1-30 RPC calls per confirmation)
2. Use `@solana/kit`'s `sendAndConfirmTransactionFactory` (WebSocket-based)

**Decision: Option 2**

**Reasoning:**
- `@solana/kit` already provides battle-tested confirmation logic
- Uses WebSocket subscriptions (1 subscription) instead of polling (1-30 RPC calls)
- Handles blockhash expiry automatically via `createBlockHeightExceedencePromiseFactory`
- Matches modern Solana SDK patterns - don't reinvent the wheel
- Less code to maintain in our SDK

**Trade-off:** Requires `rpcSubscriptions` parameter (WebSocket connection).

**Why this is acceptable:**
- Production facilitators (our primary users) already have WebSocket connections
- WebSocket confirmation IS the industry best practice
- Users without WebSocket can use low-level `executeSplit()` instruction builder
- We shouldn't encourage polling by making it the easy path

**How it works internally:**

```typescript
import { sendAndConfirmTransactionFactory } from '@solana/kit';

// Creates a confirmation function that uses WebSocket subscriptions
const sendAndConfirm = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });

// Internally races:
// 1. createRecentSignatureConfirmationPromiseFactory → WebSocket subscription for status
// 2. createBlockHeightExceedencePromiseFactory → WebSocket subscription for block height
// Returns when confirmed OR throws SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED if expired
await sendAndConfirm(signedTransaction, { commitment: 'confirmed' });
```

### 2.7 Decision: Auto-Detect Token Program (Token-2022 Support)

**Problem:** Vaults can be SPL Token or Token-2022 ATAs. Hardcoding `TOKEN_PROGRAM_ID` breaks Token-2022 splits.

**Options considered:**
1. Require caller to pass `tokenProgram` option
2. Auto-detect from vault account owner

**Decision: Option 2 (auto-detect)**

**Reasoning:**
- Zero additional RPC calls — vault account is already fetched for balance check
- Better DX — caller doesn't need to track which token program each vault uses
- Vault's `owner` field in AccountInfo IS the token program

```typescript
// Extract token program from vault account owner
const vaultAccountInfo = await rpc.getAccountInfo(vault, { encoding: "base64" }).send();
const tokenProgram = vaultAccountInfo.value?.owner as Address;
```

### 2.8 Decision: Support Compute Budget Instructions

**Problem:** During Solana congestion, transactions without priority fees get dropped. Production facilitators need control.

### 2.9 Note: @solana/web3.js Compatibility

**Existing functions remain fully compatible:**

| Function | web3.js Compatible | Bridge |
|----------|-------------------|--------|
| `executeSplit()` | ✅ Yes | `toWeb3Instruction(result.instruction)` |
| `createSplitConfig()` | ✅ Yes | `toWeb3Instruction(result.instruction)` |
| `isCascadeSplit()` | ✅ Yes | Returns boolean, no conversion needed |
| `getSplitConfigFromVault()` | ✅ Yes | Returns plain objects with `Address` strings |

**NEW `executeAndConfirmSplit()` is kit-native:**

- `KeyPairSigner` parameter: bridgeable via `toKitSigner(keypair)` ✅
- `rpcSubscriptions` parameter: **no web3.js equivalent** ⚠️

web3.js `Connection` uses callback-based subscriptions, while `@solana/kit` uses async iterators. No simple bridge exists.

**Migration path for web3.js users:**

```typescript
// Option 1: Continue using low-level API (recommended for web3.js users)
import { executeSplit } from "@cascade-fyi/splits-sdk/solana";
import { toWeb3Instruction } from "@cascade-fyi/splits-sdk/solana/web3-compat";

const result = await executeSplit(rpc, vault, executor);
if (result.ok) {
  const tx = new Transaction().add(toWeb3Instruction(result.instruction));
  const signature = await connection.sendTransaction(tx, [keypair]);
  await connection.confirmTransaction(signature);  // web3.js confirmation
}

// Option 2: Adopt @solana/kit for new high-level API
import { createSolanaRpc, createSolanaRpcSubscriptions } from "@solana/kit";
import { executeAndConfirmSplit } from "@cascade-fyi/splits-sdk/solana";
import { toKitSigner } from "@cascade-fyi/splits-sdk/solana/web3-compat";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");
const rpcSubscriptions = createSolanaRpcSubscriptions("wss://api.mainnet-beta.solana.com");
const signer = await toKitSigner(keypair);

const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer);
```

**Why not provide `executeAndConfirmSplitLegacy`?**

- Would duplicate significant logic
- web3.js confirmation (`confirmTransaction`) is being deprecated upstream
- Encourages migration to kit patterns (industry direction)
- Low-level `executeSplit()` already covers the use case

**Decision: Add optional compute budget parameters**

**Reasoning:**
- Critical for production reliability during network congestion
- Optional — no overhead when not used
- Standard pattern for Solana production apps

```typescript
// With priority fee during congestion
const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer, {
  computeUnitLimit: 150_000,      // Measured CU for execute_split
  computeUnitPrice: 50_000n,      // 50k microlamports per CU
});
```

---

## Part 3: Caching for `isCascadeSplit`

### 3.1 The Problem

Without caching, a facilitator processing 100k tx/hour:
- Calls `isCascadeSplit` 100k times
- Each call = 2 RPC requests
- Total: 200k RPC/hour just for split detection

Most of these are:
- Repeat addresses (same customers paying multiple times)
- Non-split vaults (regular wallet addresses)

### 3.2 Key Insight: When Is Caching Safe?

**Positive results (is a split):**
- If vault IS a split vault, it will remain one
- Vault owner = SplitConfig PDA (derived deterministically)
- **Safe to cache indefinitely** (edge case: split closed, but execution just fails gracefully)

**Negative results (not a split):**
- If account EXISTS and is not a split, it can't become one
- The vault address of any future split is derived from `(splitConfig, mint)`
- Existing account at address X can't collide with future split's vault
- **Safe to cache if account exists**

**Account doesn't exist:**
- Could be created as a split vault later
- **Do NOT cache**

### 3.3 Decision: Boolean Cache with Error-Aware Logic

**Options considered:**
1. Cache `{ splitConfig, mint }` for potential optimization
2. Cache just `boolean`

**Decision: Option 2 (boolean)**

**Reasoning:**
- `executeSplit` always fetches full `SplitConfig` anyway (needs recipients)
- Caching `splitConfig` address saves zero RPC calls
- Boolean is simpler, same effectiveness

### 3.4 Error Handling Design

```typescript
try {
  await getSplitConfigFromVault(rpc, vault);
  splitCache.set(key, true);
  return true;
} catch (e) {
  if (e instanceof VaultNotFoundError) {
    // Account doesn't exist - might be created as split later
    return false;  // DON'T CACHE
  }
  if (
    e instanceof InvalidTokenAccountError ||
    e instanceof SplitConfigNotFoundError
  ) {
    // Account exists but definitively not a split
    splitCache.set(key, false);  // SAFE TO CACHE
    return false;
  }
  // Unknown error (RPC failure, etc.) - don't cache, propagate
  throw e;  // DON'T CACHE, PROPAGATE
}
```

**Reasoning:**

| Error | Cache? | Why |
|-------|--------|-----|
| `VaultNotFoundError` | No | Account could be created as split |
| `InvalidTokenAccountError` | Yes | Existing data format can't change |
| `SplitConfigNotFoundError` | Yes | Token owner can't become SplitConfig PDA |
| RPC/network error | No | Transient - would create persistent false negatives |

### 3.5 RPC/WebSocket Cost Analysis

**Confirmation cost comparison (per transaction):**

| Method | Cost |
|--------|------|
| Polling (rejected approach) | 1-30 RPC calls |
| WebSocket (our approach) | 1 subscription |

**Total `executeAndConfirmSplit` flow:**

| Step | RPC Calls | WebSocket |
|------|-----------|-----------|
| `isCascadeSplit` (cached, if used by caller) | 0 | - |
| `getVaultBalanceAndOwner` | 1 | - |
| `executeSplit` → `getSplitConfigFromVault` | 2 | - |
| `getLatestBlockhash` | 1 | - |
| `sendTransaction` | 1 | - |
| Confirmation | - | 1 subscription |
| **Total** | **5 RPC** | **1 WS subscription** |

**Caching impact on `isCascadeSplit`:**

| Scenario | RPC/hour | Reduction |
|----------|----------|-----------|
| No caching | 200k+ | - |
| Cold cache (hour 1) | ~20k | 90% |
| Warm cache (hour 2+) | ~2k | **99%** |

### 3.6 Decision: Module-Level Singleton Cache

**Options considered:**
1. Module-level singleton (implicit)
2. Explicit cache injection via factory

**Decision: Option 1 with escape hatches**

**Reasoning:**
- Simpler API - just call `isCascadeSplit()`, caching is automatic
- Export control functions for edge cases:
  - `invalidateSplitCache(vault)` - after `closeSplitConfig`
  - `clearSplitCache()` - service restart scenarios

### 3.7 Decision: No LRU/Size Limit Initially

**Reasoning:**
- 100k entries × ~100 bytes = ~10MB (negligible)
- Even 1M entries = ~100MB
- For server-side facilitators, this is not a concern
- Can add LRU in v0.9.0 if real-world usage shows need

### 3.8 Protocol Config Caching

**Problem:** Every `executeSplit` fetches protocol config (for fee_wallet). But protocol config rarely changes.

**Decision: Cache with auto-invalidation on error**

**Reasoning:**
- Fee wallet changes are rare (yearly at most)
- If fee_wallet changes, transaction fails with `InvalidProtocolFeeRecipient`
- On that specific error: invalidate cache → retry once → succeeds
- Zero coordination needed between protocol and facilitators
- Self-healing, no manual intervention

```typescript
// Module-level cache
let cachedProtocolConfig: ProtocolConfig | null = null;

export async function getProtocolConfig(rpc: Rpc<SolanaRpcApi>): Promise<ProtocolConfig> {
  if (cachedProtocolConfig) {
    return cachedProtocolConfig;
  }

  const address = await deriveProtocolConfig();
  const account = await fetchProtocolConfig(rpc, address);

  cachedProtocolConfig = {
    address,
    authority: account.data.authority,
    pendingAuthority: account.data.pendingAuthority,
    feeWallet: account.data.feeWallet,
    bump: account.data.bump,
  };

  return cachedProtocolConfig;
}

export function invalidateProtocolConfigCache(): void {
  cachedProtocolConfig = null;
}
```

**In `executeAndConfirmSplit` error handling:**

```typescript
// Extract program error code using @solana/kit's type-safe API
let programErrorCode: number | undefined;
if (isSolanaError(e, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {
  programErrorCode = e.context.code;  // TypeScript knows this is { code: number, index: number }
}

// Auto-retry on stale protocol config (fee_wallet changed)
if (programErrorCode === INVALID_PROTOCOL_FEE_RECIPIENT && !options._isRetry) {
  invalidateProtocolConfigCache();
  return executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer, {
    ...options,
    _isRetry: true
  });
}
```

### 3.9 Browser vs Node.js Cache Behavior

The cache uses a module-level `Map`, which behaves differently per environment:

| Environment | Cache Lifetime | Implication |
|-------------|----------------|-------------|
| **Node.js** | Process lifetime (days/weeks) | Full benefit - massive RPC savings |
| **Browser** | Page session (until refresh) | Limited benefit - sessions are short |

**This is intentional, not a bug:**
- Server facilitators (primary use case) get persistent caching
- Browser users get per-session caching (still helps for repeated checks)
- No special handling needed - `Map` works identically in both environments

**Documentation requirement:** Add note to README explaining this behavior.

---

## Part 4: File Structure

### Current Structure
```
packages/splits-sdk/src/
├── index.ts                    # Types, constants, conversion helpers
├── errors.ts                   # Error classes
└── solana/
    ├── index.ts                # Re-exports
    ├── instructions.ts         # Instruction builders
    ├── helpers.ts              # Read functions, PDA derivation
    ├── generated/              # Codama-generated code
    └── web3-compat/
        └── index.ts            # @solana/web3.js bridge
```

### New Structure
```
packages/splits-sdk/src/
├── index.ts                    # Types, constants, conversion helpers
├── errors.ts                   # Error classes
└── solana/
    ├── index.ts                # Re-exports (MODIFIED)
    ├── instructions.ts         # Instruction builders (UNCHANGED)
    ├── helpers.ts              # Read functions + caching (MODIFIED)
    ├── execute.ts              # Transaction execution (NEW)
    ├── generated/              # Codama-generated code
    └── web3-compat/
        └── index.ts            # @solana/web3.js bridge
```

---

## Part 5: Detailed Implementation

### 5.1 New File: `src/solana/execute.ts`

```typescript
/**
 * Transaction execution helpers for Cascade Splits
 *
 * High-level functions that handle the full transaction lifecycle:
 * build instruction → sign → send → confirm
 *
 * Uses @solana/kit's sendAndConfirmTransactionFactory for efficient
 * WebSocket-based confirmation (no polling).
 */

import {
  type Address,
  type Rpc,
  type SolanaRpcApi,
  type KeyPairSigner,
  type RpcSubscriptions,
  type SignatureNotificationsApi,
  type SlotNotificationsApi,
  type Instruction,
  pipe,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  signTransactionMessageWithSigners,
  getSignatureFromTransaction,
  sendAndConfirmTransactionFactory,
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,
  SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,
} from "@solana/kit";
import {
  getSetComputeUnitLimitInstruction,
  getSetComputeUnitPriceInstruction,
} from "@solana-program/compute-budget";
import { CASCADE_SPLITS_ERROR__INVALID_PROTOCOL_FEE_RECIPIENT } from "./generated/errors/index.js";
import { executeSplit } from "./instructions.js";
import { getVaultBalanceAndOwner, invalidateProtocolConfigCache } from "./helpers.js";

// =============================================================================
// Types
// =============================================================================

/**
 * Options for executeAndConfirmSplit
 */
export interface ExecuteAndConfirmOptions {
  /** Only execute if vault balance >= this amount (in token base units) */
  minBalance?: bigint;
  /** Commitment level for confirmation (default: 'confirmed') */
  commitment?: "processed" | "confirmed" | "finalized";
  /** Abort signal for timeout/cancellation support */
  abortSignal?: AbortSignal;
  /** Compute unit limit (default: 200_000) */
  computeUnitLimit?: number;
  /** Priority fee in microlamports per compute unit */
  computeUnitPrice?: bigint;
  /** @internal Prevents infinite retry loop on protocol config mismatch */
  _isRetry?: boolean;
}

/**
 * Result of executeAndConfirmSplit
 */
export type ExecuteAndConfirmResult =
  | { ok: true; signature: string }
  | { ok: false; reason: "not_found" | "not_a_split" | "below_threshold" }
  | { ok: false; reason: "send_failed" | "expired" | "aborted"; error: Error; programErrorCode?: number };

// =============================================================================
// Execute and Confirm
// =============================================================================

/**
 * Execute a split and wait for confirmation.
 *
 * Uses @solana/kit's sendAndConfirmTransactionFactory for efficient
 * WebSocket-based confirmation instead of polling.
 *
 * @example
 * ```typescript
 * const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer);
 * if (result.ok) {
 *   console.log(`Split executed: ${result.signature}`);
 * }
 *
 * // With minimum balance threshold
 * const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer, {
 *   minBalance: 1_000_000n, // 1 USDC
 * });
 * if (!result.ok && result.reason === "below_threshold") {
 *   console.log("Vault balance below threshold, skipping execution");
 * }
 * ```
 */
export async function executeAndConfirmSplit(
  rpc: Rpc<SolanaRpcApi>,
  rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi>,
  vault: Address,
  signer: KeyPairSigner,
  options: ExecuteAndConfirmOptions = {},
): Promise<ExecuteAndConfirmResult> {
  const {
    minBalance,
    commitment = "confirmed",
    abortSignal,
    computeUnitLimit,
    computeUnitPrice,
  } = options;

  // 1. Fetch vault balance and token program (single RPC call)
  const vaultInfo = await getVaultBalanceAndOwner(rpc, vault);
  if (!vaultInfo) {
    return { ok: false, reason: "not_found" };
  }

  const { balance, tokenProgram } = vaultInfo;

  // 2. Build instruction (checks if it's a valid split)
  const result = await executeSplit(rpc, vault, signer.address, tokenProgram);
  if (!result.ok) {
    return result;  // "not_a_split" if not a split
  }

  // 3. Check minimum balance threshold (only for valid splits)
  // This is for micropayment batching - accumulate small payments before paying gas
  if (minBalance !== undefined && balance < minBalance) {
    return { ok: false, reason: "below_threshold" };
  }

  // 4. Build instruction list (compute budget + split)
  const instructions: Instruction[] = [];

  if (computeUnitLimit !== undefined) {
    instructions.push(getSetComputeUnitLimitInstruction({ units: computeUnitLimit }));
  }
  if (computeUnitPrice !== undefined) {
    instructions.push(getSetComputeUnitPriceInstruction({ microLamports: computeUnitPrice }));
  }
  instructions.push(result.instruction);

  // 5. Build and sign transaction
  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

  const transactionMessage = pipe(
    createTransactionMessage({ version: 0 }),
    (msg) => setTransactionMessageFeePayerSigner(signer, msg),
    (msg) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, msg),
    (msg) => appendTransactionMessageInstructions(instructions, msg),
  );

  const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
  const signature = getSignatureFromTransaction(signedTransaction);

  // 6. Send and confirm using @solana/kit (WebSocket-based, efficient)
  const sendAndConfirm = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });

  try {
    await sendAndConfirm(signedTransaction, { commitment, abortSignal });
    return { ok: true, signature };
  } catch (e) {
    const error = e as Error;

    if (abortSignal?.aborted) {
      return { ok: false, reason: "aborted", error };
    }
    if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {
      return { ok: false, reason: "expired", error };
    }

    // Extract program error code using @solana/kit's type-safe API
    // SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM means a program returned a custom error
    // The context contains { code: number, index: number }
    let programErrorCode: number | undefined;
    if (isSolanaError(e, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {
      programErrorCode = e.context.code;
    }

    // Auto-retry on stale protocol config (fee_wallet changed)
    if (
      programErrorCode === CASCADE_SPLITS_ERROR__INVALID_PROTOCOL_FEE_RECIPIENT &&
      !options._isRetry
    ) {
      invalidateProtocolConfigCache();
      return executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer, {
        ...options,
        _isRetry: true,
      });
    }

    return { ok: false, reason: "send_failed", error, programErrorCode };
  }
}
```

### 5.2 Modify: `src/solana/helpers.ts`

Add `getVaultBalanceAndOwner` for efficient vault info fetching (exported for internal SDK use, but NOT re-exported from `index.ts`):

```typescript
// =============================================================================
// Vault Info (balance + token program detection)
// =============================================================================

/**
 * Vault balance and token program info
 * @internal
 */
export interface VaultInfo {
  balance: bigint;
  tokenProgram: Address;
}

/**
 * Get vault balance and token program in a single RPC call.
 * Returns null if vault doesn't exist.
 * @internal Used by executeAndConfirmSplit for Token-2022 auto-detection
 */
export async function getVaultBalanceAndOwner(
  rpc: Rpc<SolanaRpcApi>,
  vault: Address,
): Promise<VaultInfo | null> {
  const accountInfo = await rpc
    .getAccountInfo(vault, { encoding: "base64" })
    .send();

  if (!accountInfo.value) {
    return null;
  }

  const data = decodeBase64(accountInfo.value.data[0]);
  if (data.length < 72) {
    return null;  // Invalid token account
  }

  const balance = readBigUInt64LE(data, 64);
  const tokenProgram = accountInfo.value.owner as Address;

  return { balance, tokenProgram };
}
```

Add caching to `isCascadeSplit`:

```typescript
// Add at top of file, after imports
import {
  VaultNotFoundError,
  InvalidTokenAccountError,
  SplitConfigNotFoundError,
} from "../errors.js";

// =============================================================================
// Split Detection Cache
// =============================================================================

const splitCache = new Map<string, boolean>();

/**
 * Check if an address is a Cascade Split vault.
 *
 * Results are cached for efficiency:
 * - Positive results (is a split): cached indefinitely
 * - Negative results (existing account, not a split): cached indefinitely
 * - Non-existent accounts: NOT cached (could be created later)
 * - RPC errors: NOT cached (transient failures)
 */
export async function isCascadeSplit(
  rpc: Rpc<SolanaRpcApi>,
  vault: Address,
): Promise<boolean> {
  const key = vault as string;
  const cached = splitCache.get(key);

  if (cached !== undefined) {
    return cached;
  }

  try {
    await getSplitConfigFromVault(rpc, vault);
    splitCache.set(key, true);
    return true;
  } catch (e) {
    if (e instanceof VaultNotFoundError) {
      // Account doesn't exist - might be created as split later
      return false;
    }
    if (
      e instanceof InvalidTokenAccountError ||
      e instanceof SplitConfigNotFoundError
    ) {
      // Account exists but definitively not a split - safe to cache
      splitCache.set(key, false);
      return false;
    }
    // Unknown error (RPC failure, etc.) - don't cache, propagate
    throw e;
  }
}

/**
 * Invalidate cache entry for a vault.
 * Call after closeSplitConfig if immediate re-detection is needed.
 */
export function invalidateSplitCache(vault: Address): void {
  splitCache.delete(vault as string);
}

/**
 * Clear entire split detection cache.
 */
export function clearSplitCache(): void {
  splitCache.clear();
}
```

### 5.3 Modify: `src/solana/index.ts`

Add new exports:

```typescript
/**
 * Cascade Splits SDK - Solana Module
 *
 * @example
 * ```typescript
 * import {
 *   executeSplit,
 *   executeAndConfirmSplit,
 *   isCascadeSplit,
 * } from '@cascade-fyi/splits-sdk/solana';
 *
 * // Check if vault is a split
 * if (await isCascadeSplit(rpc, vault)) {
 *   // Low-level: get instruction to sign yourself
 *   const result = await executeSplit(rpc, vault, executor);
 *
 *   // High-level: execute and confirm in one call
 *   const result = await executeAndConfirmSplit(rpc, vault, signer);
 * }
 * ```
 */

// =============================================================================
// Instructions (build transactions)
// =============================================================================

export {
  createSplitConfig,
  executeSplit,
  updateSplitConfig,
  closeSplitConfig,
  type CreateSplitConfigResult,
  type ExecuteSplitResult,
} from "./instructions.js";

// =============================================================================
// Execute (high-level transaction helpers)
// =============================================================================

export {
  executeAndConfirmSplit,
  type ExecuteAndConfirmOptions,
  type ExecuteAndConfirmResult,
} from "./execute.js";

// =============================================================================
// Read & Helpers
// =============================================================================

export {
  // Read functions
  getSplitConfigFromVault,
  getProtocolConfig,
  getVaultBalance,
  // Split detection cache
  isCascadeSplit,
  invalidateSplitCache,
  clearSplitCache,
  // Protocol config cache
  invalidateProtocolConfigCache,
  // PDA derivation
  deriveSplitConfig,
  deriveVault,
  deriveAta,
  deriveProtocolConfig,
  // Utilities
  generateUniqueId,
  // Types
  type SplitConfig,
  type SplitRecipient,
  type ProtocolConfig,
  type UnclaimedAmount,
} from "./helpers.js";
```

---

## Part 6: Version & Changelog

### 6.1 Version Bump

```json
{
  "version": "0.8.0"
}
```

### 6.2 Dependencies

Add to `packages/splits-sdk/package.json`:

```json
{
  "dependencies": {
    "@solana/compat": "^5.0.0",
    "@solana-program/compute-budget": "^0.11.0",  // NEW
    "bs58": "^6.0.0"
  }
}
```

**Note:** `@solana-program/compute-budget` is maintained by the Solana Program org (solana-program/compute-budget on GitHub) and has `@solana/kit ^5.0` as peer dependency — matches our SDK.

### 6.3 CHANGELOG Entry

```markdown
## [0.8.0] - 2025-12-XX

### Added

- **`executeAndConfirmSplit()`** - High-level helper that builds, signs, sends, and confirms split execution in one call
  - `ExecuteAndConfirmOptions` - Configuration for minimum balance threshold, commitment, abort signal, and compute budget
  - `ExecuteAndConfirmResult` - Discriminated union for type-safe result handling
  - `minBalance` option for micropayment batching - skip execution if vault balance below threshold
  - `abortSignal` option for timeout/cancellation support - matches `@solana/kit` patterns
  - `computeUnitLimit` and `computeUnitPrice` options for priority fee support during network congestion
  - `programErrorCode` in error results for debugging on-chain failures
  - Auto-detects Token-2022 from vault account owner (no manual tokenProgram needed)

- **`isCascadeSplit()` caching** - Automatic caching of split detection results for RPC efficiency
  - Positive results cached indefinitely (vault is a split)
  - Negative results cached for existing accounts (can't become a split)
  - Non-existent accounts NOT cached (could be created as split later)
  - RPC errors NOT cached (transient failures should retry)
  - ~75% reduction in RPC calls for high-volume facilitators

- **Cache control functions**
  - `invalidateSplitCache(vault)` - Clear cache for specific vault
  - `clearSplitCache()` - Clear entire cache
  - `invalidateProtocolConfigCache()` - Clear protocol config cache

- **Protocol config caching** - Automatic caching with self-healing on fee_wallet changes
  - Cached after first fetch, saves 1 RPC per `executeSplit`
  - Auto-invalidates and retries on `InvalidProtocolFeeRecipient` error
  - Zero coordination needed when protocol changes fee_wallet

### Internal

- New `execute.ts` module for transaction execution helpers
- Clean separation: `instructions.ts` (build) vs `execute.ts` (execute)
- Added `@solana-program/compute-budget` dependency for priority fees
```

---

## Part 7: Testing Requirements

### 7.0 Testing Strategy for WebSocket-Dependent Code

**Problem:** `executeAndConfirmSplit` uses `sendAndConfirmTransactionFactory` which requires WebSocket. LiteSVM (our test harness) doesn't support WebSocket subscriptions.

**Solution: Layered Testing**

| Layer | What | How | Coverage |
|-------|------|-----|----------|
| **Unit** | Logic paths | Mock `sendAndConfirmTransactionFactory` via Vitest | All result types, retry logic |
| **Integration** | Components | LiteSVM | `getVaultBalanceAndOwner`, caching, instruction building |
| **E2E** | Full flow | Real devnet + WebSocket | One happy path smoke test |

**Vitest Mocking Pattern:**

```typescript
import { vi, describe, it, expect, beforeEach } from "vitest";
import * as kit from "@solana/kit";

// Mock the factory at module level
vi.mock("@solana/kit", async (importOriginal) => {
  const actual = await importOriginal<typeof kit>();
  return {
    ...actual,
    sendAndConfirmTransactionFactory: vi.fn(),
  };
});

describe("executeAndConfirmSplit", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("returns signature on success", async () => {
    // Mock factory to return a function that resolves
    vi.mocked(kit.sendAndConfirmTransactionFactory).mockReturnValue(
      vi.fn().mockResolvedValue(undefined)
    );

    const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer);
    expect(result).toEqual({ ok: true, signature: expect.any(String) });
  });

  it("returns expired when blockhash expires", async () => {
    const blockHeightError = new kit.SolanaError(
      kit.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,
      { /* context */ }
    );
    vi.mocked(kit.sendAndConfirmTransactionFactory).mockReturnValue(
      vi.fn().mockRejectedValue(blockHeightError)
    );

    const result = await executeAndConfirmSplit(rpc, rpcSubscriptions, vault, signer);
    expect(result).toEqual({ ok: false, reason: "expired", error: blockHeightError });
  });
});
```

**Why this approach:**
- Unit tests cover all code paths without network dependencies
- Integration tests verify instruction building works with on-chain state
- Single E2E test catches real-world issues (WebSocket handshake, RPC quirks)
- No flaky tests from network timeouts in CI

### 7.1 Unit Tests for `executeAndConfirmSplit`

```typescript
describe("executeAndConfirmSplit", () => {
  it("returns signature on success");
  it("returns not_found when vault doesn't exist");
  it("returns not_a_split when vault is not a split");
  it("returns below_threshold when balance < minBalance (only for valid splits)");
  it("returns send_failed on transaction error with programErrorCode");
  it("returns expired when blockhash expires");
  it("returns aborted when abortSignal is triggered");
  it("respects commitment option");
  it("auto-detects Token-2022 program from vault owner");
  it("adds compute budget instructions when options set");
  it("auto-retries on InvalidProtocolFeeRecipient (stale fee_wallet)");
  it("does not retry more than once on InvalidProtocolFeeRecipient");
  it("executes even when vault balance is 0 (may have unclaimed amounts)");
});
```

### 7.2 Unit Tests for Caching

```typescript
describe("isCascadeSplit caching", () => {
  it("caches positive results");
  it("caches negative results for existing non-split accounts");
  it("does NOT cache when account doesn't exist");
  it("does NOT cache on RPC errors");
  it("invalidateSplitCache clears specific entry");
  it("clearSplitCache clears all entries");
});

describe("protocol config caching", () => {
  it("caches protocol config after first fetch");
  it("returns cached config on subsequent calls");
  it("invalidateProtocolConfigCache clears cache");
  it("refetches after invalidation");
});
```

---

## Part 8: Future Considerations (v0.9.0+)

### 8.1 Timing-Based Batching

```typescript
// Future: BatchExecutor with rate limiting
const executor = createBatchExecutor(rpc, {
  minBalance: 1_000_000n,
  minInterval: 60_000, // Max once per minute per vault
});

await executor.maybeExecute(vault, signer);
```

### 8.2 EVM Support

```typescript
// Future: src/evm/ module
import { executeAndConfirmSplit } from "@cascade-fyi/splits-sdk/evm";

await executeAndConfirmSplit(publicClient, walletClient, vault);
```

**Important: Keep result types chain-specific.**

Do NOT prematurely abstract result types across chains:

```typescript
// ❌ DON'T: Forced abstraction
type ExecuteResult = { ok: true; txId: string };  // What's txId? Signature? Hash?

// ✅ DO: Chain-specific types
// src/solana/execute.ts
type ExecuteAndConfirmResult = { ok: true; signature: string } | ...;

// src/evm/execute.ts (future)
type ExecuteAndConfirmResult = { ok: true; txHash: string } | ...;
```

**Reasoning:**
- Solana uses `signature` (base58 string)
- EVM uses `txHash` (0x-prefixed hex)
- Different semantics - Solana signatures are signer proofs, EVM hashes are transaction identifiers
- Faremeter already handles this by having separate `/payment-solana` and `/payment-evm` packages
- Premature abstraction creates leaky interfaces

### 8.3 LRU Cache (if needed)

```typescript
// Future: If memory becomes concern
const splitCache = createLRUCache<boolean>({ maxSize: 100_000 });
```

---

## Summary

| Item | Decision | Reasoning |
|------|----------|-----------|
| Execution logic | In SDK, not faremeter wrapper | Thin wrapper = easier approval |
| Multi-chain | Subpath exports | Tree-shaking, separate dependencies |
| New function location | `execute.ts` | Clean separation of concerns |
| Confirmation | `@solana/kit` `sendAndConfirmTransactionFactory` | WebSocket-based, no polling, battle-tested |
| Batching | `minBalance` only | Stateless, timing needs app-level state |
| Timeout/cancellation | `abortSignal` option | Matches `@solana/kit` patterns |
| Token-2022 | Auto-detect from vault owner | Zero additional RPC, better DX |
| Priority fees | `computeUnitLimit` + `computeUnitPrice` options | Critical for production during congestion |
| Empty vault handling | Let on-chain program decide | May have unclaimed amounts to distribute |
| Error codes | `programErrorCode` in error results | Debuggability for on-chain failures |
| Split cache storage | Boolean | `splitConfig` caching saves 0 RPC |
| Split cache scope | Module singleton | Simpler API, escape hatches provided |
| Split cache errors | Error-type aware | Prevents persistent false negatives |
| Protocol config cache | Auto-invalidate on error | Self-healing, zero coordination |
| Cache environments | Same code, different lifetimes | Node.js = process, Browser = session |
| Error handling | Include original error | Debuggability for `send_failed` cases |
| EVM types | Chain-specific, not abstracted | Avoid leaky interfaces |
| Breaking changes | None | All additive |
| web3.js compat | Existing APIs ✅, new `executeAndConfirmSplit` kit-native | Low-level API covers web3.js users |
| Testing | Layered (unit + integration + E2E) | Mock WebSocket in unit, real in E2E |

**Total new code: ~200 lines**
**Impact: 75% RPC reduction + faremeter-ready API + production-grade priority fee support**
