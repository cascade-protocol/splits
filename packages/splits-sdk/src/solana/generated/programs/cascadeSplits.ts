/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedAcceptProtocolAuthorityInstruction,
  type ParsedCloseSplitConfigInstruction,
  type ParsedCreateSplitConfigInstruction,
  type ParsedExecuteSplitInstruction,
  type ParsedInitializeProtocolInstruction,
  type ParsedTransferProtocolAuthorityInstruction,
  type ParsedUpdateProtocolConfigInstruction,
  type ParsedUpdateSplitConfigInstruction,
} from '../instructions';

export const CASCADE_SPLITS_PROGRAM_ADDRESS =
  'SPL1T3rERcu6P6dyBiG7K8LUr21CssZqDAszwANzNMB' as Address<'SPL1T3rERcu6P6dyBiG7K8LUr21CssZqDAszwANzNMB'>;

export enum CascadeSplitsAccount {
  ProtocolConfig,
  SplitConfig,
}

export function identifyCascadeSplitsAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): CascadeSplitsAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([207, 91, 250, 28, 152, 179, 215, 209])
      ),
      0
    )
  ) {
    return CascadeSplitsAccount.ProtocolConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([49, 201, 50, 228, 22, 142, 12, 222])
      ),
      0
    )
  ) {
    return CascadeSplitsAccount.SplitConfig;
  }
  throw new Error(
    'The provided account could not be identified as a cascadeSplits account.'
  );
}

export enum CascadeSplitsInstruction {
  AcceptProtocolAuthority,
  CloseSplitConfig,
  CreateSplitConfig,
  ExecuteSplit,
  InitializeProtocol,
  TransferProtocolAuthority,
  UpdateProtocolConfig,
  UpdateSplitConfig,
}

export function identifyCascadeSplitsInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): CascadeSplitsInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([237, 122, 6, 39, 53, 202, 141, 113])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.AcceptProtocolAuthority;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([170, 202, 252, 92, 196, 160, 247, 229])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.CloseSplitConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([128, 42, 60, 106, 4, 233, 18, 190])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.CreateSplitConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([6, 45, 171, 40, 49, 129, 23, 89])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.ExecuteSplit;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([188, 233, 252, 106, 134, 146, 202, 91])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.InitializeProtocol;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([35, 76, 36, 77, 136, 112, 158, 222])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.TransferProtocolAuthority;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([197, 97, 123, 54, 221, 168, 11, 135])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.UpdateProtocolConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([47, 103, 74, 170, 55, 251, 130, 146])
      ),
      0
    )
  ) {
    return CascadeSplitsInstruction.UpdateSplitConfig;
  }
  throw new Error(
    'The provided instruction could not be identified as a cascadeSplits instruction.'
  );
}

export type ParsedCascadeSplitsInstruction<
  TProgram extends string = 'SPL1T3rERcu6P6dyBiG7K8LUr21CssZqDAszwANzNMB',
> =
  | ({
      instructionType: CascadeSplitsInstruction.AcceptProtocolAuthority;
    } & ParsedAcceptProtocolAuthorityInstruction<TProgram>)
  | ({
      instructionType: CascadeSplitsInstruction.CloseSplitConfig;
    } & ParsedCloseSplitConfigInstruction<TProgram>)
  | ({
      instructionType: CascadeSplitsInstruction.CreateSplitConfig;
    } & ParsedCreateSplitConfigInstruction<TProgram>)
  | ({
      instructionType: CascadeSplitsInstruction.ExecuteSplit;
    } & ParsedExecuteSplitInstruction<TProgram>)
  | ({
      instructionType: CascadeSplitsInstruction.InitializeProtocol;
    } & ParsedInitializeProtocolInstruction<TProgram>)
  | ({
      instructionType: CascadeSplitsInstruction.TransferProtocolAuthority;
    } & ParsedTransferProtocolAuthorityInstruction<TProgram>)
  | ({
      instructionType: CascadeSplitsInstruction.UpdateProtocolConfig;
    } & ParsedUpdateProtocolConfigInstruction<TProgram>)
  | ({
      instructionType: CascadeSplitsInstruction.UpdateSplitConfig;
    } & ParsedUpdateSplitConfigInstruction<TProgram>);
