/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	combineCodec,
	fixDecoderSize,
	fixEncoderSize,
	getAddressDecoder,
	getAddressEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getProgramDerivedAddress,
	getStructDecoder,
	getStructEncoder,
	transformEncoder,
	type AccountMeta,
	type AccountSignerMeta,
	type Address,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlyAccount,
	type ReadonlyUint8Array,
	type TransactionSigner,
	type WritableAccount,
	type WritableSignerAccount,
} from "@solana/kit";
import { CASCADE_SPLITS_PROGRAM_ADDRESS } from "../programs";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared";

export const INITIALIZE_PROTOCOL_DISCRIMINATOR = new Uint8Array([
	188, 233, 252, 106, 134, 146, 202, 91,
]);

export function getInitializeProtocolDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(
		INITIALIZE_PROTOCOL_DISCRIMINATOR,
	);
}

export type InitializeProtocolInstruction<
	TProgram extends string = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
	TAccountProtocolConfig extends string | AccountMeta<string> = string,
	TAccountAuthority extends string | AccountMeta<string> = string,
	TAccountProgramData extends string | AccountMeta<string> = string,
	TAccountSystemProgram extends
		| string
		| AccountMeta<string> = "11111111111111111111111111111111",
	TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
	InstructionWithData<ReadonlyUint8Array> &
	InstructionWithAccounts<
		[
			TAccountProtocolConfig extends string
				? WritableAccount<TAccountProtocolConfig>
				: TAccountProtocolConfig,
			TAccountAuthority extends string
				? WritableSignerAccount<TAccountAuthority> &
						AccountSignerMeta<TAccountAuthority>
				: TAccountAuthority,
			TAccountProgramData extends string
				? ReadonlyAccount<TAccountProgramData>
				: TAccountProgramData,
			TAccountSystemProgram extends string
				? ReadonlyAccount<TAccountSystemProgram>
				: TAccountSystemProgram,
			...TRemainingAccounts,
		]
	>;

export type InitializeProtocolInstructionData = {
	discriminator: ReadonlyUint8Array;
	feeWallet: Address;
};

export type InitializeProtocolInstructionDataArgs = { feeWallet: Address };

export function getInitializeProtocolInstructionDataEncoder(): FixedSizeEncoder<InitializeProtocolInstructionDataArgs> {
	return transformEncoder(
		getStructEncoder([
			["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
			["feeWallet", getAddressEncoder()],
		]),
		(value) => ({ ...value, discriminator: INITIALIZE_PROTOCOL_DISCRIMINATOR }),
	);
}

export function getInitializeProtocolInstructionDataDecoder(): FixedSizeDecoder<InitializeProtocolInstructionData> {
	return getStructDecoder([
		["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
		["feeWallet", getAddressDecoder()],
	]);
}

export function getInitializeProtocolInstructionDataCodec(): FixedSizeCodec<
	InitializeProtocolInstructionDataArgs,
	InitializeProtocolInstructionData
> {
	return combineCodec(
		getInitializeProtocolInstructionDataEncoder(),
		getInitializeProtocolInstructionDataDecoder(),
	);
}

export type InitializeProtocolAsyncInput<
	TAccountProtocolConfig extends string = string,
	TAccountAuthority extends string = string,
	TAccountProgramData extends string = string,
	TAccountSystemProgram extends string = string,
> = {
	protocolConfig?: Address<TAccountProtocolConfig>;
	authority: TransactionSigner<TAccountAuthority>;
	programData: Address<TAccountProgramData>;
	systemProgram?: Address<TAccountSystemProgram>;
	feeWallet: InitializeProtocolInstructionDataArgs["feeWallet"];
};

export async function getInitializeProtocolInstructionAsync<
	TAccountProtocolConfig extends string,
	TAccountAuthority extends string,
	TAccountProgramData extends string,
	TAccountSystemProgram extends string,
	TProgramAddress extends Address = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
>(
	input: InitializeProtocolAsyncInput<
		TAccountProtocolConfig,
		TAccountAuthority,
		TAccountProgramData,
		TAccountSystemProgram
	>,
	config?: { programAddress?: TProgramAddress },
): Promise<
	InitializeProtocolInstruction<
		TProgramAddress,
		TAccountProtocolConfig,
		TAccountAuthority,
		TAccountProgramData,
		TAccountSystemProgram
	>
> {
	// Program address.
	const programAddress =
		config?.programAddress ?? CASCADE_SPLITS_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		protocolConfig: { value: input.protocolConfig ?? null, isWritable: true },
		authority: { value: input.authority ?? null, isWritable: true },
		programData: { value: input.programData ?? null, isWritable: false },
		systemProgram: { value: input.systemProgram ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<
		keyof typeof originalAccounts,
		ResolvedAccount
	>;

	// Original args.
	const args = { ...input };

	// Resolve default values.
	if (!accounts.protocolConfig.value) {
		accounts.protocolConfig.value = await getProgramDerivedAddress({
			programAddress,
			seeds: [
				getBytesEncoder().encode(
					new Uint8Array([
						112, 114, 111, 116, 111, 99, 111, 108, 95, 99, 111, 110, 102, 105,
						103,
					]),
				),
			],
		});
	}
	if (!accounts.systemProgram.value) {
		accounts.systemProgram.value =
			"11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
	}

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
	return Object.freeze({
		accounts: [
			getAccountMeta(accounts.protocolConfig),
			getAccountMeta(accounts.authority),
			getAccountMeta(accounts.programData),
			getAccountMeta(accounts.systemProgram),
		],
		data: getInitializeProtocolInstructionDataEncoder().encode(
			args as InitializeProtocolInstructionDataArgs,
		),
		programAddress,
	} as InitializeProtocolInstruction<
		TProgramAddress,
		TAccountProtocolConfig,
		TAccountAuthority,
		TAccountProgramData,
		TAccountSystemProgram
	>);
}

export type InitializeProtocolInput<
	TAccountProtocolConfig extends string = string,
	TAccountAuthority extends string = string,
	TAccountProgramData extends string = string,
	TAccountSystemProgram extends string = string,
> = {
	protocolConfig: Address<TAccountProtocolConfig>;
	authority: TransactionSigner<TAccountAuthority>;
	programData: Address<TAccountProgramData>;
	systemProgram?: Address<TAccountSystemProgram>;
	feeWallet: InitializeProtocolInstructionDataArgs["feeWallet"];
};

export function getInitializeProtocolInstruction<
	TAccountProtocolConfig extends string,
	TAccountAuthority extends string,
	TAccountProgramData extends string,
	TAccountSystemProgram extends string,
	TProgramAddress extends Address = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
>(
	input: InitializeProtocolInput<
		TAccountProtocolConfig,
		TAccountAuthority,
		TAccountProgramData,
		TAccountSystemProgram
	>,
	config?: { programAddress?: TProgramAddress },
): InitializeProtocolInstruction<
	TProgramAddress,
	TAccountProtocolConfig,
	TAccountAuthority,
	TAccountProgramData,
	TAccountSystemProgram
> {
	// Program address.
	const programAddress =
		config?.programAddress ?? CASCADE_SPLITS_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		protocolConfig: { value: input.protocolConfig ?? null, isWritable: true },
		authority: { value: input.authority ?? null, isWritable: true },
		programData: { value: input.programData ?? null, isWritable: false },
		systemProgram: { value: input.systemProgram ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<
		keyof typeof originalAccounts,
		ResolvedAccount
	>;

	// Original args.
	const args = { ...input };

	// Resolve default values.
	if (!accounts.systemProgram.value) {
		accounts.systemProgram.value =
			"11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
	}

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
	return Object.freeze({
		accounts: [
			getAccountMeta(accounts.protocolConfig),
			getAccountMeta(accounts.authority),
			getAccountMeta(accounts.programData),
			getAccountMeta(accounts.systemProgram),
		],
		data: getInitializeProtocolInstructionDataEncoder().encode(
			args as InitializeProtocolInstructionDataArgs,
		),
		programAddress,
	} as InitializeProtocolInstruction<
		TProgramAddress,
		TAccountProtocolConfig,
		TAccountAuthority,
		TAccountProgramData,
		TAccountSystemProgram
	>);
}

export type ParsedInitializeProtocolInstruction<
	TProgram extends string = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
	programAddress: Address<TProgram>;
	accounts: {
		protocolConfig: TAccountMetas[0];
		authority: TAccountMetas[1];
		programData: TAccountMetas[2];
		systemProgram: TAccountMetas[3];
	};
	data: InitializeProtocolInstructionData;
};

export function parseInitializeProtocolInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[],
>(
	instruction: Instruction<TProgram> &
		InstructionWithAccounts<TAccountMetas> &
		InstructionWithData<ReadonlyUint8Array>,
): ParsedInitializeProtocolInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 4) {
		// TODO: Coded error.
		throw new Error("Not enough accounts");
	}
	let accountIndex = 0;
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
		accountIndex += 1;
		return accountMeta;
	};
	return {
		programAddress: instruction.programAddress,
		accounts: {
			protocolConfig: getNextAccount(),
			authority: getNextAccount(),
			programData: getNextAccount(),
			systemProgram: getNextAccount(),
		},
		data: getInitializeProtocolInstructionDataDecoder().decode(
			instruction.data,
		),
	};
}
