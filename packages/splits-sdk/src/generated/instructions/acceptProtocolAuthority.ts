/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	combineCodec,
	fixDecoderSize,
	fixEncoderSize,
	getBytesDecoder,
	getBytesEncoder,
	getProgramDerivedAddress,
	getStructDecoder,
	getStructEncoder,
	transformEncoder,
	type AccountMeta,
	type AccountSignerMeta,
	type Address,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlySignerAccount,
	type ReadonlyUint8Array,
	type TransactionSigner,
	type WritableAccount,
} from "@solana/kit";
import { CASCADE_SPLITS_PROGRAM_ADDRESS } from "../programs";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared";

export const ACCEPT_PROTOCOL_AUTHORITY_DISCRIMINATOR = new Uint8Array([
	237, 122, 6, 39, 53, 202, 141, 113,
]);

export function getAcceptProtocolAuthorityDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(
		ACCEPT_PROTOCOL_AUTHORITY_DISCRIMINATOR,
	);
}

export type AcceptProtocolAuthorityInstruction<
	TProgram extends string = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
	TAccountProtocolConfig extends string | AccountMeta<string> = string,
	TAccountNewAuthority extends string | AccountMeta<string> = string,
	TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
	InstructionWithData<ReadonlyUint8Array> &
	InstructionWithAccounts<
		[
			TAccountProtocolConfig extends string
				? WritableAccount<TAccountProtocolConfig>
				: TAccountProtocolConfig,
			TAccountNewAuthority extends string
				? ReadonlySignerAccount<TAccountNewAuthority> &
						AccountSignerMeta<TAccountNewAuthority>
				: TAccountNewAuthority,
			...TRemainingAccounts,
		]
	>;

export type AcceptProtocolAuthorityInstructionData = {
	discriminator: ReadonlyUint8Array;
};

export type AcceptProtocolAuthorityInstructionDataArgs = {};

export function getAcceptProtocolAuthorityInstructionDataEncoder(): FixedSizeEncoder<AcceptProtocolAuthorityInstructionDataArgs> {
	return transformEncoder(
		getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
		(value) => ({
			...value,
			discriminator: ACCEPT_PROTOCOL_AUTHORITY_DISCRIMINATOR,
		}),
	);
}

export function getAcceptProtocolAuthorityInstructionDataDecoder(): FixedSizeDecoder<AcceptProtocolAuthorityInstructionData> {
	return getStructDecoder([
		["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
	]);
}

export function getAcceptProtocolAuthorityInstructionDataCodec(): FixedSizeCodec<
	AcceptProtocolAuthorityInstructionDataArgs,
	AcceptProtocolAuthorityInstructionData
> {
	return combineCodec(
		getAcceptProtocolAuthorityInstructionDataEncoder(),
		getAcceptProtocolAuthorityInstructionDataDecoder(),
	);
}

export type AcceptProtocolAuthorityAsyncInput<
	TAccountProtocolConfig extends string = string,
	TAccountNewAuthority extends string = string,
> = {
	protocolConfig?: Address<TAccountProtocolConfig>;
	newAuthority: TransactionSigner<TAccountNewAuthority>;
};

export async function getAcceptProtocolAuthorityInstructionAsync<
	TAccountProtocolConfig extends string,
	TAccountNewAuthority extends string,
	TProgramAddress extends Address = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
>(
	input: AcceptProtocolAuthorityAsyncInput<
		TAccountProtocolConfig,
		TAccountNewAuthority
	>,
	config?: { programAddress?: TProgramAddress },
): Promise<
	AcceptProtocolAuthorityInstruction<
		TProgramAddress,
		TAccountProtocolConfig,
		TAccountNewAuthority
	>
> {
	// Program address.
	const programAddress =
		config?.programAddress ?? CASCADE_SPLITS_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		protocolConfig: { value: input.protocolConfig ?? null, isWritable: true },
		newAuthority: { value: input.newAuthority ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<
		keyof typeof originalAccounts,
		ResolvedAccount
	>;

	// Resolve default values.
	if (!accounts.protocolConfig.value) {
		accounts.protocolConfig.value = await getProgramDerivedAddress({
			programAddress,
			seeds: [
				getBytesEncoder().encode(
					new Uint8Array([
						112, 114, 111, 116, 111, 99, 111, 108, 95, 99, 111, 110, 102, 105,
						103,
					]),
				),
			],
		});
	}

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
	return Object.freeze({
		accounts: [
			getAccountMeta(accounts.protocolConfig),
			getAccountMeta(accounts.newAuthority),
		],
		data: getAcceptProtocolAuthorityInstructionDataEncoder().encode({}),
		programAddress,
	} as AcceptProtocolAuthorityInstruction<
		TProgramAddress,
		TAccountProtocolConfig,
		TAccountNewAuthority
	>);
}

export type AcceptProtocolAuthorityInput<
	TAccountProtocolConfig extends string = string,
	TAccountNewAuthority extends string = string,
> = {
	protocolConfig: Address<TAccountProtocolConfig>;
	newAuthority: TransactionSigner<TAccountNewAuthority>;
};

export function getAcceptProtocolAuthorityInstruction<
	TAccountProtocolConfig extends string,
	TAccountNewAuthority extends string,
	TProgramAddress extends Address = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
>(
	input: AcceptProtocolAuthorityInput<
		TAccountProtocolConfig,
		TAccountNewAuthority
	>,
	config?: { programAddress?: TProgramAddress },
): AcceptProtocolAuthorityInstruction<
	TProgramAddress,
	TAccountProtocolConfig,
	TAccountNewAuthority
> {
	// Program address.
	const programAddress =
		config?.programAddress ?? CASCADE_SPLITS_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		protocolConfig: { value: input.protocolConfig ?? null, isWritable: true },
		newAuthority: { value: input.newAuthority ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<
		keyof typeof originalAccounts,
		ResolvedAccount
	>;

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
	return Object.freeze({
		accounts: [
			getAccountMeta(accounts.protocolConfig),
			getAccountMeta(accounts.newAuthority),
		],
		data: getAcceptProtocolAuthorityInstructionDataEncoder().encode({}),
		programAddress,
	} as AcceptProtocolAuthorityInstruction<
		TProgramAddress,
		TAccountProtocolConfig,
		TAccountNewAuthority
	>);
}

export type ParsedAcceptProtocolAuthorityInstruction<
	TProgram extends string = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
	programAddress: Address<TProgram>;
	accounts: {
		protocolConfig: TAccountMetas[0];
		newAuthority: TAccountMetas[1];
	};
	data: AcceptProtocolAuthorityInstructionData;
};

export function parseAcceptProtocolAuthorityInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[],
>(
	instruction: Instruction<TProgram> &
		InstructionWithAccounts<TAccountMetas> &
		InstructionWithData<ReadonlyUint8Array>,
): ParsedAcceptProtocolAuthorityInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 2) {
		// TODO: Coded error.
		throw new Error("Not enough accounts");
	}
	let accountIndex = 0;
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
		accountIndex += 1;
		return accountMeta;
	};
	return {
		programAddress: instruction.programAddress,
		accounts: {
			protocolConfig: getNextAccount(),
			newAuthority: getNextAccount(),
		},
		data: getAcceptProtocolAuthorityInstructionDataDecoder().decode(
			instruction.data,
		),
	};
}
