/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	AccountRole,
	combineCodec,
	fixDecoderSize,
	fixEncoderSize,
	getArrayDecoder,
	getArrayEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getStructDecoder,
	getStructEncoder,
	transformEncoder,
	type AccountMeta,
	type AccountSignerMeta,
	type Address,
	type Codec,
	type Decoder,
	type Encoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlyAccount,
	type ReadonlySignerAccount,
	type ReadonlyUint8Array,
	type TransactionSigner,
	type WritableAccount,
} from "@solana/kit";
import { CASCADE_SPLITS_PROGRAM_ADDRESS } from "../programs";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared";
import {
	getRecipientInputDecoder,
	getRecipientInputEncoder,
	type RecipientInput,
	type RecipientInputArgs,
} from "../types";

export const UPDATE_SPLIT_CONFIG_DISCRIMINATOR = new Uint8Array([
	47, 103, 74, 170, 55, 251, 130, 146,
]);

export function getUpdateSplitConfigDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(
		UPDATE_SPLIT_CONFIG_DISCRIMINATOR,
	);
}

export type UpdateSplitConfigInstruction<
	TProgram extends string = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
	TAccountSplitConfig extends string | AccountMeta<string> = string,
	TAccountVault extends string | AccountMeta<string> = string,
	TAccountMint extends string | AccountMeta<string> = string,
	TAccountAuthority extends string | AccountMeta<string> = string,
	TAccountTokenProgram extends
		| string
		| AccountMeta<string> = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
	TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
	InstructionWithData<ReadonlyUint8Array> &
	InstructionWithAccounts<
		[
			TAccountSplitConfig extends string
				? WritableAccount<TAccountSplitConfig>
				: TAccountSplitConfig,
			TAccountVault extends string
				? ReadonlyAccount<TAccountVault>
				: TAccountVault,
			TAccountMint extends string
				? ReadonlyAccount<TAccountMint>
				: TAccountMint,
			TAccountAuthority extends string
				? ReadonlySignerAccount<TAccountAuthority> &
						AccountSignerMeta<TAccountAuthority>
				: TAccountAuthority,
			TAccountTokenProgram extends string
				? ReadonlyAccount<TAccountTokenProgram>
				: TAccountTokenProgram,
			...TRemainingAccounts,
		]
	>;

export type UpdateSplitConfigInstructionData = {
	discriminator: ReadonlyUint8Array;
	newRecipients: Array<RecipientInput>;
};

export type UpdateSplitConfigInstructionDataArgs = {
	newRecipients: Array<RecipientInputArgs>;
};

export function getUpdateSplitConfigInstructionDataEncoder(): Encoder<UpdateSplitConfigInstructionDataArgs> {
	return transformEncoder(
		getStructEncoder([
			["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
			["newRecipients", getArrayEncoder(getRecipientInputEncoder())],
		]),
		(value) => ({ ...value, discriminator: UPDATE_SPLIT_CONFIG_DISCRIMINATOR }),
	);
}

export function getUpdateSplitConfigInstructionDataDecoder(): Decoder<UpdateSplitConfigInstructionData> {
	return getStructDecoder([
		["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
		["newRecipients", getArrayDecoder(getRecipientInputDecoder())],
	]);
}

export function getUpdateSplitConfigInstructionDataCodec(): Codec<
	UpdateSplitConfigInstructionDataArgs,
	UpdateSplitConfigInstructionData
> {
	return combineCodec(
		getUpdateSplitConfigInstructionDataEncoder(),
		getUpdateSplitConfigInstructionDataDecoder(),
	);
}

export type UpdateSplitConfigInput<
	TAccountSplitConfig extends string = string,
	TAccountVault extends string = string,
	TAccountMint extends string = string,
	TAccountAuthority extends string = string,
	TAccountTokenProgram extends string = string,
> = {
	splitConfig: Address<TAccountSplitConfig>;
	vault: Address<TAccountVault>;
	mint: Address<TAccountMint>;
	authority: TransactionSigner<TAccountAuthority>;
	tokenProgram?: Address<TAccountTokenProgram>;
	newRecipients: UpdateSplitConfigInstructionDataArgs["newRecipients"];
	recipientAtas: Array<Address>;
};

export function getUpdateSplitConfigInstruction<
	TAccountSplitConfig extends string,
	TAccountVault extends string,
	TAccountMint extends string,
	TAccountAuthority extends string,
	TAccountTokenProgram extends string,
	TProgramAddress extends Address = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
>(
	input: UpdateSplitConfigInput<
		TAccountSplitConfig,
		TAccountVault,
		TAccountMint,
		TAccountAuthority,
		TAccountTokenProgram
	>,
	config?: { programAddress?: TProgramAddress },
): UpdateSplitConfigInstruction<
	TProgramAddress,
	TAccountSplitConfig,
	TAccountVault,
	TAccountMint,
	TAccountAuthority,
	TAccountTokenProgram
> {
	// Program address.
	const programAddress =
		config?.programAddress ?? CASCADE_SPLITS_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		splitConfig: { value: input.splitConfig ?? null, isWritable: true },
		vault: { value: input.vault ?? null, isWritable: false },
		mint: { value: input.mint ?? null, isWritable: false },
		authority: { value: input.authority ?? null, isWritable: false },
		tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<
		keyof typeof originalAccounts,
		ResolvedAccount
	>;

	// Original args.
	const args = { ...input };

	// Resolve default values.
	if (!accounts.tokenProgram.value) {
		accounts.tokenProgram.value =
			"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
	}

	// Remaining accounts.
	const remainingAccounts: AccountMeta[] = args.recipientAtas.map(
		(address) => ({ address, role: AccountRole.READONLY }),
	);

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
	return Object.freeze({
		accounts: [
			getAccountMeta(accounts.splitConfig),
			getAccountMeta(accounts.vault),
			getAccountMeta(accounts.mint),
			getAccountMeta(accounts.authority),
			getAccountMeta(accounts.tokenProgram),
			...remainingAccounts,
		],
		data: getUpdateSplitConfigInstructionDataEncoder().encode(
			args as UpdateSplitConfigInstructionDataArgs,
		),
		programAddress,
	} as UpdateSplitConfigInstruction<
		TProgramAddress,
		TAccountSplitConfig,
		TAccountVault,
		TAccountMint,
		TAccountAuthority,
		TAccountTokenProgram
	>);
}

export type ParsedUpdateSplitConfigInstruction<
	TProgram extends string = typeof CASCADE_SPLITS_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
	programAddress: Address<TProgram>;
	accounts: {
		splitConfig: TAccountMetas[0];
		vault: TAccountMetas[1];
		mint: TAccountMetas[2];
		authority: TAccountMetas[3];
		tokenProgram: TAccountMetas[4];
	};
	data: UpdateSplitConfigInstructionData;
};

export function parseUpdateSplitConfigInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[],
>(
	instruction: Instruction<TProgram> &
		InstructionWithAccounts<TAccountMetas> &
		InstructionWithData<ReadonlyUint8Array>,
): ParsedUpdateSplitConfigInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 5) {
		// TODO: Coded error.
		throw new Error("Not enough accounts");
	}
	let accountIndex = 0;
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
		accountIndex += 1;
		return accountMeta;
	};
	return {
		programAddress: instruction.programAddress,
		accounts: {
			splitConfig: getNextAccount(),
			vault: getNextAccount(),
			mint: getNextAccount(),
			authority: getNextAccount(),
			tokenProgram: getNextAccount(),
		},
		data: getUpdateSplitConfigInstructionDataDecoder().decode(instruction.data),
	};
}
